---
title: "functions"
format: html
editor: visual
---

```{r}
library(tidyverse)
```


### Function Fundamentals

While the formals and body are specified explicitly when you create a function, the environment is specified implicitly, based on where you defined the function.
- Primitive functons like `[` and `sum()` are exceptions as they call C code directly

Importantly, R functions are objects themselves. If you choose not to give a function a name, you get an anonymous function. In R, you’ll often see functions called closures. This name reflects the fact that R functions capture, or enclose, their environments.

#### Invoking a function

```{r}
mean(1:10, na.rm = T)

args <- list(1:10, na.rm = T)
do.call(mean, args)
```

#### Exercises

1. Given a name, like "mean", `match.fun()` lets you find a function. Given a function, can you find its name? Why doesn’t that make sense in R?

Well there is no one-to-one mapping between functions and names. 

2. It’s possible (although typically not useful) to call an anonymous function. Which of the two approaches below is correct? Why?

```{r, eval=F}
function(x) 3()

(function(x) 3)()

```

The second approach seems to be the correct one because the parentheses help define the function body before calling it.

3. What function allows you to tell if an object is a function? What function allows you to tell if a function is a primitive function?

Not sure about this one. `is.function(x)` and `is.primitive()` both seem to say in their documentation that they check for whether their arguments are primitive functions.


4. This code makes a list of all functions in the base package.

```{r}
objs <- mget(ls("package:base", all = TRUE), inherits = TRUE)
funs <- Filter(is.function, objs)
```

Use it to answer the following questions:

- Which base function has the most arguments?

```{r}
funs %>% 
  map_int(function(x) length(formals(x))) %>%
  sort(decreasing = T) %>%
  head(1)
```


- How many base functions have no arguments? What’s special about those functions?

```{r}
funs %>% 
  discard(is.primitive) %>% 
  map_df(function(x) length(formals(x))) %>% 
  t() %>% 
  as.data.frame() %>% 
  count(V1 == 0)
  
  
```
only 47, and most are primitive.

- How could you adapt the code to find all primitive functions?

```{r}
prims <- Filter(is.primitive, objs)
```

### Lexical Scoping

Scoping: the act of finding a value associated with a name

Lexing scoping means that R looks up the values of a name based on how a function is defined, not just on how it is called. Parse-time rather than run-time structure

- name masking: names defined inside of a function mask names defined outside of a function. First, R looks inside the current function. Then, it looks where that function was defined (and so on, all the way up to the global environment). Finally, it looks in other loaded packages.
- a fresh start: everytime a function is called, a new environment is created to host it's execution.

